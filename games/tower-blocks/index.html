<!DOCTYPE html><html lang="en"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><title>PlayLab Kids</title><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="manifest" href="/manifest.json"><meta name="description" content="Discover a world of fun, hands-on games designed just for kids! From swirling sensory screens to brain-boosting puzzles, PlayLab Kids offers safe, interactive experiences that spark curiosity, creativity, and learning."><meta name="theme-color" content="#18181b"><meta property="og:title" content="PlayLab Kids"><meta property="og:description" content="Discover a world of fun, hands-on games designed just for kids! From swirling sensory screens to brain-boosting puzzles, PlayLab Kids offers safe, interactive experiences that spark curiosity, creativity, and learning."><meta property="og:image" content="https://kosskollective.com/1200x630.png"><script src="https://unpkg.com/@botpoison/browser" async></script><link rel="preload" href="/_astro/fonts/735b820ba6e864a1.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="/_astro/fonts/bfec8551693c6f9e.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="/_astro/fonts/70f2961c284fc994.woff2" as="font" type="font/woff2" crossorigin><style>@font-face{font-family:InterLocal-1905dcbe019de8d3;src:url("/_astro/fonts/735b820ba6e864a1.woff2") format("woff2");font-display:swap;font-weight:400;font-style:normal;}@font-face{font-family:InterLocal-1905dcbe019de8d3;src:url("/_astro/fonts/bfec8551693c6f9e.woff2") format("woff2");font-display:swap;font-weight:600;font-style:normal;}@font-face{font-family:InterLocal-1905dcbe019de8d3;src:url("/_astro/fonts/70f2961c284fc994.woff2") format("woff2");font-display:swap;font-weight:700;font-style:normal;}@font-face{font-family:"InterLocal-1905dcbe019de8d3 fallback: Arial";src:local("Arial");font-display:swap;font-weight:400;font-style:normal;size-adjust:107.1194%;ascent-override:90.4365%;descent-override:22.518%;line-gap-override:0%;}@font-face{font-family:"InterLocal-1905dcbe019de8d3 fallback: Arial";src:local("Arial");font-display:swap;font-weight:600;font-style:normal;size-adjust:107.1194%;ascent-override:90.4365%;descent-override:22.518%;line-gap-override:0%;}@font-face{font-family:"InterLocal-1905dcbe019de8d3 fallback: Arial";src:local("Arial");font-display:swap;font-weight:700;font-style:normal;size-adjust:107.1194%;ascent-override:90.4365%;descent-override:22.518%;line-gap-override:0%;}:root{--font-inter:InterLocal-1905dcbe019de8d3,"InterLocal-1905dcbe019de8d3 fallback: Arial",sans-serif;}</style><link rel="preload" href="/_astro/fonts/6d3e4d52f48ad98b.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="/_astro/fonts/5136b46f8749c158.woff2" as="font" type="font/woff2" crossorigin><link rel="preload" href="/_astro/fonts/021ffd72b125f319.woff2" as="font" type="font/woff2" crossorigin><style>@font-face{font-family:InterLocalDisplay-8c5dbcbd1c66ec4c;src:url("/_astro/fonts/6d3e4d52f48ad98b.woff2") format("woff2");font-display:swap;font-weight:400;font-style:normal;}@font-face{font-family:InterLocalDisplay-8c5dbcbd1c66ec4c;src:url("/_astro/fonts/5136b46f8749c158.woff2") format("woff2");font-display:swap;font-weight:500;font-style:normal;}@font-face{font-family:InterLocalDisplay-8c5dbcbd1c66ec4c;src:url("/_astro/fonts/021ffd72b125f319.woff2") format("woff2");font-display:swap;font-weight:600;font-style:normal;}@font-face{font-family:"InterLocalDisplay-8c5dbcbd1c66ec4c fallback: Arial";src:local("Arial");font-display:swap;font-weight:400;font-style:normal;size-adjust:97.6999%;ascent-override:99.1557%;descent-override:24.689%;line-gap-override:0%;}@font-face{font-family:"InterLocalDisplay-8c5dbcbd1c66ec4c fallback: Arial";src:local("Arial");font-display:swap;font-weight:500;font-style:normal;size-adjust:97.6999%;ascent-override:99.1557%;descent-override:24.689%;line-gap-override:0%;}@font-face{font-family:"InterLocalDisplay-8c5dbcbd1c66ec4c fallback: Arial";src:local("Arial");font-display:swap;font-weight:600;font-style:normal;size-adjust:97.6999%;ascent-override:99.1557%;descent-override:24.689%;line-gap-override:0%;}:root{--font-inter-display:InterLocalDisplay-8c5dbcbd1c66ec4c,"InterLocalDisplay-8c5dbcbd1c66ec4c fallback: Arial",sans-serif;}</style><link rel="stylesheet" href="/_astro/animal-sounds.Bv_XTzeZ.css">
<style>@import"https://fonts.googleapis.com/css?family=Comfortaa";html,body{margin:0;overflow:hidden;height:100%;width:100%;position:relative;font-family:Comfortaa,cursive}#container[data-astro-cid-6rcmxsgr]{width:100%;height:100%}#container[data-astro-cid-6rcmxsgr] #score[data-astro-cid-6rcmxsgr]{position:absolute;top:50px;width:100%;text-align:center;font-size:10vh;transition:transform .5s ease;color:#334;transform:translatey(-200px) scale(1)}#container[data-astro-cid-6rcmxsgr] .game-over[data-astro-cid-6rcmxsgr]{position:absolute;top:0;left:0;width:100%;height:85%;display:flex;flex-direction:column;align-items:center;justify-content:center}#container[data-astro-cid-6rcmxsgr] .game-over[data-astro-cid-6rcmxsgr] [data-astro-cid-6rcmxsgr]{transition:opacity .5s ease,transform .5s ease;opacity:0;transform:translatey(-50px);color:#334}#container[data-astro-cid-6rcmxsgr] .game-over[data-astro-cid-6rcmxsgr] h2[data-astro-cid-6rcmxsgr]{margin:0;padding:0;font-size:40px}#container[data-astro-cid-6rcmxsgr] .game-ready[data-astro-cid-6rcmxsgr]{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:space-around}#container[data-astro-cid-6rcmxsgr] .game-ready[data-astro-cid-6rcmxsgr] #start-button[data-astro-cid-6rcmxsgr]{transition:opacity .5s ease,transform .5s ease;opacity:0;transform:translatey(-50px);border:3px solid #333344;padding:10px 20px;background-color:transparent;color:#334;font-size:30px}#container[data-astro-cid-6rcmxsgr] #instructions[data-astro-cid-6rcmxsgr]{color:#334;position:absolute;width:100%;top:20vh;left:0;text-align:center;transition:opacity .5s ease,transform .5s ease;opacity:0}#container[data-astro-cid-6rcmxsgr] #instructions[data-astro-cid-6rcmxsgr].hide{opacity:0!important}#container[data-astro-cid-6rcmxsgr].playing #score[data-astro-cid-6rcmxsgr],#container[data-astro-cid-6rcmxsgr].resetting #score[data-astro-cid-6rcmxsgr]{transform:translatey(0) scale(1)}#container[data-astro-cid-6rcmxsgr].playing #instructions[data-astro-cid-6rcmxsgr]{opacity:1}#container[data-astro-cid-6rcmxsgr].ready .game-ready[data-astro-cid-6rcmxsgr] #start-button[data-astro-cid-6rcmxsgr]{opacity:1;transform:translatey(0)}#container[data-astro-cid-6rcmxsgr].ended #score[data-astro-cid-6rcmxsgr]{transform:translatey(6vh) scale(1.5)}#container[data-astro-cid-6rcmxsgr].ended .game-over[data-astro-cid-6rcmxsgr] [data-astro-cid-6rcmxsgr]{opacity:1;transform:translatey(0)}#container[data-astro-cid-6rcmxsgr].ended .game-over[data-astro-cid-6rcmxsgr] p[data-astro-cid-6rcmxsgr]{transition-delay:.3s}
</style></head> <body id="top"> <!-- bg image --> <img src="/_astro/hero-image.CJcnn0bU_ZzTWg4.avif" alt loading="eager" width="1920" height="1080" decoding="async" class="absolute min-h-svh object-cover inset-0 bottom-auto -z-1 w-full h-auto opacity-20 mask-b-from-50%"> <!-- Main slot --> <main id="main">   <header class="wrapper bg-loop font-semibold"> <!-- Wrapper --> <div class="bs-container py-2 block m-auto text-center"> <!-- Logo --> <a class="inline-block m-auto text-center group" href="/" aria-label="PlayLab Kids - Home"> <!-- <Logo class="group-hover:-rotate-180 group-hover:scale-80 transition-transform ease-bs-spring duration-1000" height="48" width="48" /> --> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="group-hover:-rotate-90 group-hover:scale-80 transition-transform ease-bs-spring duration-1000"><path d="M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8"></path><path d="M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path></svg> </a> </div> </header> <div class="items-center" data-astro-cid-6rcmxsgr> <div id="container" data-astro-cid-6rcmxsgr> <div id="game" data-astro-cid-6rcmxsgr></div> <div id="score" data-astro-cid-6rcmxsgr>0</div> <div id="instructions" data-astro-cid-6rcmxsgr>Click (or press the spacebar) to place the block</div> <div class="game-over" data-astro-cid-6rcmxsgr> <h2 data-astro-cid-6rcmxsgr>Game Over</h2> <p data-astro-cid-6rcmxsgr>You did great, you're the best.</p> <p data-astro-cid-6rcmxsgr>Click or spacebar to start again</p> </div> <div class="game-ready" data-astro-cid-6rcmxsgr> <div id="start-button" data-astro-cid-6rcmxsgr>Start</div> <div data-astro-cid-6rcmxsgr></div> </div> </div> </div> <script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';
import { TweenLite, Power1 } from 'https://cdn.jsdelivr.net/npm/gsap@3.12.5/all.js';

window.addEventListener('DOMContentLoaded', () => {
    "use strict";
    console.clear();
    class Stage {
        constructor() {
            // container
            this.container = document.getElementById('game');
            // renderer
            this.renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: false
            });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setClearColor('#D0CBC7', 1);
            this.container.appendChild(this.renderer.domElement);
            // scene
            this.scene = new THREE.Scene();
            // camera
            let aspect = window.innerWidth / window.innerHeight;
            let d = 20;
            this.camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, -100, 1000);
            this.camera.position.x = 2;
            this.camera.position.y = 2;
            this.camera.position.z = 2;
            this.camera.lookAt(new THREE.Vector3(0, 0, 0));
            //light
            this.light = new THREE.DirectionalLight(0xffffff, 0.5);
            this.light.position.set(0, 499, 0);
            this.scene.add(this.light);
            this.softLight = new THREE.AmbientLight(0xffffff, 0.4);
            this.scene.add(this.softLight);
            window.addEventListener('resize', () => this.onResize());
            this.onResize();
        }
        render() {
            this.renderer.render(this.scene, this.camera);
        }
        add(elem) {
            this.scene.add(elem);
        }
        remove(elem) {
            this.scene.remove(elem);
        }
        setCamera(y, speed = 0.3) {
            TweenLite.to(this.camera.position, speed, { y: y + 4, ease: Power1.easeInOut });
        }
        onResize() {
            let viewSize = 30;
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.camera.left = window.innerWidth / -viewSize;
            this.camera.right = window.innerWidth / viewSize;
            this.camera.top = window.innerHeight / viewSize;
            this.camera.bottom = window.innerHeight / -viewSize;
            this.camera.updateProjectionMatrix();
        }
    }
    class Block {
        constructor(block) {
            // set size and position
            this.STATES = { ACTIVE: 'active', STOPPED: 'stopped', MISSED: 'missed' };
            this.MOVE_AMOUNT = 12;
            this.dimension = { width: 0, height: 0, depth: 0 };
            this.position = { x: 0, y: 0, z: 0 };
            this.targetBlock = block;
            this.index = (this.targetBlock ? this.targetBlock.index : 0) + 1;
            this.workingPlane = this.index % 2 ? 'x' : 'z';
            this.workingDimension = this.index % 2 ? 'width' : 'depth';
            // set the dimensions from the target block, or defaults.
            this.dimension.width = this.targetBlock ? this.targetBlock.dimension.width : 10;
            this.dimension.height = this.targetBlock ? this.targetBlock.dimension.height : 2;
            this.dimension.depth = this.targetBlock ? this.targetBlock.dimension.depth : 10;
            this.position.x = this.targetBlock ? this.targetBlock.position.x : 0;
            this.position.y = this.dimension.height * this.index;
            this.position.z = this.targetBlock ? this.targetBlock.position.z : 0;
            this.colorOffset = this.targetBlock ? this.targetBlock.colorOffset : Math.round(Math.random() * 100);
            // set color
            if (!this.targetBlock) {
                this.color = 0x333344;
            }
            else {
                let offset = this.index + this.colorOffset;
                var r = Math.sin(0.3 * offset) * 55 + 200;
                var g = Math.sin(0.3 * offset + 2) * 55 + 200;
                var b = Math.sin(0.3 * offset + 4) * 55 + 200;
                this.color = new THREE.Color(r / 255, g / 255, b / 255);
            }
            // state
            this.state = this.index > 1 ? this.STATES.ACTIVE : this.STATES.STOPPED;
            // set direction
            this.speed = -0.1 - (this.index * 0.005);
            if (this.speed < -4)
                this.speed = -4;
            this.direction = this.speed;
            // create block
            let geometry = new THREE.BoxGeometry(this.dimension.width, this.dimension.height, this.dimension.depth);
            geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(this.dimension.width / 2, this.dimension.height / 2, this.dimension.depth / 2));
            this.material = new THREE.MeshToonMaterial({ color: this.color });
            this.mesh = new THREE.Mesh(geometry, this.material);
            this.mesh.position.set(this.position.x, this.position.y, this.position.z);
            if (this.state == this.STATES.ACTIVE) {
                this.position[this.workingPlane] = Math.random() > 0.5 ? -this.MOVE_AMOUNT : this.MOVE_AMOUNT;
            }
        }
        reverseDirection() {
            this.direction = this.direction > 0 ? this.speed : Math.abs(this.speed);
        }
        place() {
            this.state = this.STATES.STOPPED;
            let overlap = this.targetBlock.dimension[this.workingDimension] - Math.abs(this.position[this.workingPlane] - this.targetBlock.position[this.workingPlane]);
            let blocksToReturn = {
                plane: this.workingPlane,
                direction: this.direction
            };
            if (this.dimension[this.workingDimension] - overlap < 0.3) {
                overlap = this.dimension[this.workingDimension];
                blocksToReturn.bonus = true;
                this.position.x = this.targetBlock.position.x;
                this.position.z = this.targetBlock.position.z;
                this.dimension.width = this.targetBlock.dimension.width;
                this.dimension.depth = this.targetBlock.dimension.depth;
            }
            if (overlap > 0) {
                let choppedDimensions = { width: this.dimension.width, height: this.dimension.height, depth: this.dimension.depth };
                choppedDimensions[this.workingDimension] -= overlap;
                this.dimension[this.workingDimension] = overlap;
                let placedGeometry = new THREE.BoxGeometry(this.dimension.width, this.dimension.height, this.dimension.depth);
                placedGeometry.applyMatrix4(new THREE.Matrix4().makeTranslation(this.dimension.width / 2, this.dimension.height / 2, this.dimension.depth / 2));
                let placedMesh = new THREE.Mesh(placedGeometry, this.material);
                let choppedGeometry = new THREE.BoxGeometry(choppedDimensions.width, choppedDimensions.height, choppedDimensions.depth);
                choppedGeometry.applyMatrix4(new THREE.Matrix4().makeTranslation(choppedDimensions.width / 2, choppedDimensions.height / 2, choppedDimensions.depth / 2));
                let choppedMesh = new THREE.Mesh(choppedGeometry, this.material);
                let choppedPosition = {
                    x: this.position.x,
                    y: this.position.y,
                    z: this.position.z
                };
                if (this.position[this.workingPlane] < this.targetBlock.position[this.workingPlane]) {
                    this.position[this.workingPlane] = this.targetBlock.position[this.workingPlane];
                }
                else {
                    choppedPosition[this.workingPlane] += overlap;
                }
                placedMesh.position.set(this.position.x, this.position.y, this.position.z);
                choppedMesh.position.set(choppedPosition.x, choppedPosition.y, choppedPosition.z);
                blocksToReturn.placed = placedMesh;
                if (!blocksToReturn.bonus)
                    blocksToReturn.chopped = choppedMesh;
            }
            else {
                this.state = this.STATES.MISSED;
            }
            this.dimension[this.workingDimension] = overlap;
            return blocksToReturn;
        }
        tick() {
            if (this.state == this.STATES.ACTIVE) {
                let value = this.position[this.workingPlane];
                if (value > this.MOVE_AMOUNT || value < -this.MOVE_AMOUNT)
                    this.reverseDirection();
                this.position[this.workingPlane] += this.direction;
                this.mesh.position[this.workingPlane] = this.position[this.workingPlane];
            }
        }
    }
    class Game {
        constructor() {
            this.STATES = {
                'LOADING': 'loading',
                'PLAYING': 'playing',
                'READY': 'ready',
                'ENDED': 'ended',
                'RESETTING': 'resetting'
            };
            this.blocks = [];
            this.state = this.STATES.LOADING;
            this.stage = new Stage();
            this.mainContainer = document.getElementById('container');
            this.scoreContainer = document.getElementById('score');
            this.startButton = document.getElementById('start-button');
            this.instructions = document.getElementById('instructions');
            this.scoreContainer.innerHTML = '0';
            this.newBlocks = new THREE.Group();
            this.placedBlocks = new THREE.Group();
            this.choppedBlocks = new THREE.Group();
            this.stage.add(this.newBlocks);
            this.stage.add(this.placedBlocks);
            this.stage.add(this.choppedBlocks);
            this.addBlock();
            this.tick();
            this.updateState(this.STATES.READY);
            document.addEventListener('keydown', e => {
                if (e.keyCode == 32)
                    this.onAction();
            });
            document.addEventListener('click', e => {
                this.onAction();
            });
            document.addEventListener('touchstart', e => {
                e.preventDefault();
                // this.onAction();
                // ☝️ this triggers after click on android so you
                // insta-lose, will figure it out later.
            });
        }
        updateState(newState) {
            for (let key in this.STATES)
                this.mainContainer.classList.remove(this.STATES[key]);
            this.mainContainer.classList.add(newState);
            this.state = newState;
        }
        onAction() {
            switch (this.state) {
                case this.STATES.READY:
                    this.startGame();
                    break;
                case this.STATES.PLAYING:
                    this.placeBlock();
                    break;
                case this.STATES.ENDED:
                    this.restartGame();
                    break;
            }
        }
        startGame() {
            if (this.state != this.STATES.PLAYING) {
                this.scoreContainer.innerHTML = '0';
                this.updateState(this.STATES.PLAYING);
                this.addBlock();
            }
        }
        restartGame() {
            this.updateState(this.STATES.RESETTING);
            let oldBlocks = this.placedBlocks.children;
            let removeSpeed = 0.2;
            let delayAmount = 0.02;
            for (let i = 0; i < oldBlocks.length; i++) {
                TweenLite.to(oldBlocks[i].scale, removeSpeed, { x: 0, y: 0, z: 0, delay: (oldBlocks.length - i) * delayAmount, ease: Power1.easeIn, onComplete: () => this.placedBlocks.remove(oldBlocks[i]) });
                TweenLite.to(oldBlocks[i].rotation, removeSpeed, { y: 0.5, delay: (oldBlocks.length - i) * delayAmount, ease: Power1.easeIn });
            }
            let cameraMoveSpeed = removeSpeed * 2 + (oldBlocks.length * delayAmount);
            this.stage.setCamera(2, cameraMoveSpeed);
            let countdown = { value: this.blocks.length - 1 };
            TweenLite.to(countdown, cameraMoveSpeed, { value: 0, onUpdate: () => { this.scoreContainer.innerHTML = String(Math.round(countdown.value)); } });
            this.blocks = this.blocks.slice(0, 1);
            setTimeout(() => {
                this.startGame();
            }, cameraMoveSpeed * 1000);
        }
        placeBlock() {
            let currentBlock = this.blocks[this.blocks.length - 1];
            let newBlocks = currentBlock.place();
            this.newBlocks.remove(currentBlock.mesh);
            if (newBlocks.placed)
                this.placedBlocks.add(newBlocks.placed);
            if (newBlocks.chopped) {
                this.choppedBlocks.add(newBlocks.chopped);
                let positionParams = { y: '-=30', ease: Power1.easeIn, onComplete: () => this.choppedBlocks.remove(newBlocks.chopped) };
                let rotateRandomness = 10;
                let rotationParams = {
                    delay: 0.05,
                    x: newBlocks.plane == 'z' ? ((Math.random() * rotateRandomness) - (rotateRandomness / 2)) : 0.1,
                    z: newBlocks.plane == 'x' ? ((Math.random() * rotateRandomness) - (rotateRandomness / 2)) : 0.1,
                    y: Math.random() * 0.1,
                };
                if (newBlocks.chopped.position[newBlocks.plane] > newBlocks.placed.position[newBlocks.plane]) {
                    positionParams[newBlocks.plane] = '+=' + (40 * Math.abs(newBlocks.direction));
                }
                else {
                    positionParams[newBlocks.plane] = '-=' + (40 * Math.abs(newBlocks.direction));
                }
                TweenLite.to(newBlocks.chopped.position, 1, positionParams);
                TweenLite.to(newBlocks.chopped.rotation, 1, rotationParams);
            }
            this.addBlock();
        }
        addBlock() {
            let lastBlock = this.blocks[this.blocks.length - 1];
            if (lastBlock && lastBlock.state == lastBlock.STATES.MISSED) {
                return this.endGame();
            }
            this.scoreContainer.innerHTML = String(this.blocks.length - 1);
            let newKidOnTheBlock = new Block(lastBlock);
            this.newBlocks.add(newKidOnTheBlock.mesh);
            this.blocks.push(newKidOnTheBlock);
            this.stage.setCamera(this.blocks.length * 2);
            if (this.blocks.length >= 5)
                this.instructions.classList.add('hide');
        }
        endGame() {
            this.updateState(this.STATES.ENDED);
        }
        tick() {
            this.blocks[this.blocks.length - 1].tick();
            this.stage.render();
            requestAnimationFrame(() => { this.tick(); });
        }
    }
    let game = new Game();
});
</script>  </main> </body></html>